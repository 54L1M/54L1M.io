<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture | 54L1M</title>
<meta name=keywords content="kubernetes,raspberry-pi,homelab,k3s,p4ndalab,k8s"><meta name=description content="Dive into the core concepts and architecture of Kubernetes as I explain what makes it the industry standard for container orchestration and why K3s is perfect for a Raspberry Pi homelab. This post breaks down the control plane components, worker nodes, networking principles, and fundamental Kubernetes objects, setting the foundation for our upcoming hands-on implementation."><meta name=author content="Salim"><link rel=canonical href=https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/><link crossorigin=anonymous href=/assets/css/stylesheet.38f771ce326cca8c20edcece6ca5dbbf94a3b20e082cd168fe77858bee9ead6a.css integrity="sha256-OPdxzjJsyowg7c7ObKXbv5Sjsg4ILNFo/neFi+6erWo=" rel="preload stylesheet" as=style><link rel=icon href=https://54L1M.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://54L1M.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://54L1M.io/favicon-32x32.png><link rel=apple-touch-icon href=https://54L1M.io/apple-touch-icon.png><link rel=mask-icon href=https://54L1M.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/"><meta property="og:site_name" content="54L1M"><meta property="og:title" content="P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture"><meta property="og:description" content="Dive into the core concepts and architecture of Kubernetes as I explain what makes it the industry standard for container orchestration and why K3s is perfect for a Raspberry Pi homelab. This post breaks down the control plane components, worker nodes, networking principles, and fundamental Kubernetes objects, setting the foundation for our upcoming hands-on implementation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-11T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-11T00:00:00+00:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Raspberry-Pi"><meta property="article:tag" content="Homelab"><meta property="article:tag" content="K3s"><meta property="article:tag" content="P4ndalab"><meta property="article:tag" content="K8s"><meta property="og:image" content="https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core.png"><meta property="og:see_also" content="https://54L1M.io/2025/05/introducing-p4ndalab-my-kubernetes-homelab-journey-on-raspberry-pi/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core.png"><meta name=twitter:title content="P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture"><meta name=twitter:description content="Dive into the core concepts and architecture of Kubernetes as I explain what makes it the industry standard for container orchestration and why K3s is perfect for a Raspberry Pi homelab. This post breaks down the control plane components, worker nodes, networking principles, and fundamental Kubernetes objects, setting the foundation for our upcoming hands-on implementation."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://54L1M.io/posts/"},{"@type":"ListItem","position":2,"name":"P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture","item":"https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture","name":"P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture","description":"Dive into the core concepts and architecture of Kubernetes as I explain what makes it the industry standard for container orchestration and why K3s is perfect for a Raspberry Pi homelab. This post breaks down the control plane components, worker nodes, networking principles, and fundamental Kubernetes objects, setting the foundation for our upcoming hands-on implementation.","keywords":["kubernetes","raspberry-pi","homelab","k3s","p4ndalab","k8s"],"articleBody":"Introduction Welcome to the second post in my P4ndaLab series! Last time, I introduced you to my Raspberry Pi Kubernetes homelab project and outlined my learning journey. Today, we’re diving into Kubernetes itself - what it is, why it matters, and how it’s structured. This post combines both theoretical concepts and architectural details to give you a solid foundation before we get our hands dirty with the implementation.\nAs I mentioned in my first post, I believe in learning by doing. But to do effectively, we first need to understand what we’re working with. So let’s unpack this powerful technology that’s reshaping how we deploy and manage applications.\nWhat is Kubernetes? At its core, Kubernetes (often abbreviated as K8s - 8 letters between ‘K’ and ’s’) is an open-source container orchestration platform. But what does that actually mean?\nThink of it this way: if containers (like Docker) are a better way to package and run individual applications, Kubernetes is a better way to manage many containers across multiple machines. It automates the deployment, scaling, and management of containerized applications, handling all the complex logistics so you don’t have to.\nOriginally developed by Google based on their internal system called Borg, Kubernetes was released as an open-source project in 2014 and is now maintained by the Cloud Native Computing Foundation (CNCF). It has since become the industry standard for container orchestration.\nWhy Kubernetes Matters You might wonder why we need something as complex as Kubernetes, especially for a homelab. Here’s why it’s worth learning:\nAutomation at scale: Kubernetes automates many manual processes involved in deploying and scaling applications. Self-healing capabilities: If a container fails, Kubernetes can automatically restart it or replace it. Service discovery and load balancing: Kubernetes can expose containers using DNS names or IP addresses and distribute network traffic. Storage orchestration: You can mount storage systems of your choice, whether local or cloud-based. Declarative configuration: You tell Kubernetes what you want your deployed application to look like, and it figures out how to make it happen. Portable across environments: Whether running on-premises, in a public cloud, or a hybrid setup, Kubernetes works the same way. For my P4ndaLab, Kubernetes provides a consistent platform to experiment with modern application deployment patterns and technologies that are widely used in the industry.\nKubernetes vs. Traditional Deployment To better understand Kubernetes, let’s compare it with traditional deployment methods:\nTraditional Deployment Applications run directly on physical servers One application per server to avoid resource conflicts Results in underutilized hardware and high maintenance costs Scaling requires provisioning new servers Disaster recovery is manual and time-consuming Virtualized Deployment Multiple VMs run on a single physical server Applications isolated within VMs Better resource utilization than traditional deployment Scaling still relatively complex VM provisioning and maintenance overhead Container Deployment Lightweight and portable Share OS kernel but isolated at process level Fast startup and lower overhead than VMs Easy to build and deploy Still need container orchestration for production use Kubernetes Deployment Automates container management across multiple nodes Declarative approach to application deployment Built-in scaling, load balancing, and self-healing Infrastructure abstraction - you work with logical resources Consistent environment from development to production The Kubernetes Architecture Now that we understand what Kubernetes is and why it matters, let’s look at how it’s built. Kubernetes follows a master-worker architecture that’s both elegant and robust.\nHigh-Level View At a high level, a Kubernetes cluster consists of two types of nodes:\nControl Plane (Master) Nodes: Manage the cluster Worker Nodes: Run the actual workloads (your applications) Here’s a simplified view of what this looks like:\n┌─────────────────────────────────────────────────────────────┐ │ Kubernetes Cluster │ │ │ │ ┌───────────────────────┐ ┌──────────────────────┐ │ │ │ Control Plane │ │ Worker Node 1 │ │ │ │ │ │ │ │ │ │ ┌─────────────────┐ │ │ ┌───────────────┐ │ │ │ │ │ API Server │ │ │ │ Kubelet │ │ │ │ │ └─────────────────┘ │ │ └───────────────┘ │ │ │ │ │ │ │ │ │ │ ┌─────────────────┐ │ │ ┌───────────────┐ │ │ │ │ │ Scheduler │ │ │ │ Kube-proxy │ │ │ │ │ └─────────────────┘ │ │ └───────────────┘ │ │ │ │ │ │ │ │ │ │ ┌─────────────────┐ │ │ ┌───────────────┐ │ │ │ │ │ Controller Mgr │ │ │ │ Container RT │ │ │ │ │ └─────────────────┘ │ │ └───────────────┘ │ │ │ │ │ │ │ │ │ │ ┌─────────────────┐ │ │ ┌───────────────┐ │ │ │ │ │ etcd │ │ │ │ Pods │ │ │ │ │ └─────────────────┘ │ │ └───────────────┘ │ │ │ └───────────────────────┘ └──────────────────────┘ │ │ │ │ ┌──────────────────────┐ │ │ │ Worker Node 2 │ │ │ │ ... │ │ │ └──────────────────────┘ │ └─────────────────────────────────────────────────────────────┘ Let’s break down each component in detail.\nControl Plane Components The control plane is the brain of Kubernetes. Its components make global decisions about the cluster and detect and respond to events. In a production environment, control plane components are typically run across multiple computers for high availability, but for our P4ndaLab, they’ll run on a single node.\nAPI Server (kube-apiserver) The API server is the front door to the Kubernetes control plane. All external communication with the cluster goes through the API server - whether it’s from users running kubectl commands, other parts of the control plane, or external systems.\nKey responsibilities:\nValidates and processes API requests Acts as a gateway for the control plane Serves as the connection point for all components Performs authentication and authorization Provides RESTful API operations The API server is designed to scale horizontally, meaning you can run multiple instances to distribute load.\netcd Think of etcd as the cluster’s database. It’s a consistent, distributed key-value store that reliably stores all of Kubernetes’ configuration data and cluster state.\nKey responsibilities:\nStores all cluster data Provides watch-based notification of changes Offers strong consistency guarantees Provides the single source of truth for the cluster When you execute a command like kubectl get pods, the API server reads data from etcd. When you create a new deployment, that configuration is stored in etcd.\nScheduler (kube-scheduler) The scheduler’s job is to assign newly created pods to nodes. It’s like an intelligent dispatcher that decides where each workload should run.\nKey responsibilities:\nWatches for newly created pods with no assigned node Selects the best node for each pod based on various factors Considers resource requirements, hardware/software constraints, and affinity/anti-affinity specifications Makes binding decisions (assigns pods to nodes) The scheduler doesn’t actually place the pod on the node; it simply updates the pod definition with the node assignment, and the kubelet on that node does the rest.\nController Manager (kube-controller-manager) The controller manager runs controller processes that regulate the state of the cluster. A controller is a control loop that watches the shared state of the cluster and makes changes to move the current state towards the desired state.\nKey controllers:\nNode Controller: Notices and responds when nodes go down Replication Controller: Maintains the correct number of pods for each ReplicaSet Endpoints Controller: Populates Endpoint objects (joins Services \u0026 Pods) Service Account \u0026 Token Controllers: Create default accounts and API access tokens Cloud Controller Manager This component links your cluster with your cloud provider’s API. For a homelab setup like ours, this component isn’t particularly relevant since we’re not running in a cloud environment. But it’s worth knowing about for completeness.\nWorker Node Components Worker nodes are the machines where your applications actually run. Each node includes the services necessary to run pods and is managed by the control plane.\nKubelet The kubelet is an agent that runs on each node in the cluster. It’s responsible for making sure that containers are running in a pod.\nKey responsibilities:\nCommunicates with the API server Takes a set of PodSpecs and ensures the containers described are running and healthy Reports node and pod status to the master Runs container health checks Manages container lifecycle based on PodSpecs Kube-proxy Kube-proxy is a network proxy that runs on each node, implementing part of the Kubernetes Service concept.\nKey responsibilities:\nMaintains network rules on nodes Handles network communications inside or outside of your cluster Performs connection forwarding Implements services abstraction Kube-proxy uses the operating system packet filtering layer if available, otherwise, it forwards the traffic itself.\nContainer Runtime The container runtime is the software responsible for running containers. Kubernetes supports several container runtimes including Docker, containerd, and CRI-O.\nFor our P4ndaLab, we’ll be using K3s, which includes containerd as its container runtime by default.\nK3s: Kubernetes for Resource-Constrained Environments Speaking of K3s, let’s talk about what makes it special and why I’ve chosen it for P4ndaLab.\nWhat is K3s? K3s is a certified Kubernetes distribution designed for resource-constrained environments like IoT devices, edge computing, and in our case, a Raspberry Pi. Created by Rancher Labs (now part of SUSE), K3s packages Kubernetes as a single binary less than 100MB in size.\nK3s vs Standard Kubernetes (K8s) Feature Standard K8s K3s Binary size ~200MB+ \u003c100MB Memory footprint 2GB+ recommended 512MB minimum Setup complexity High Low (single command) External dependencies Multiple Minimal Default components Minimal Includes storage, load balancer, etc. Storage backend etcd SQLite (default) or etcd K3s Architecture Specifics K3s modifies the standard Kubernetes architecture to be more lightweight:\nSingle Binary: Combines control plane components for efficiency Embedded Components: Includes containerd, Flannel, CoreDNS, local storage provider, Traefik ingress, and more Simplified Management: Automatic TLS certificate generation and rotation Storage Options: Uses SQLite by default for single-node deployments, with etcd available for HA clusters For our Raspberry Pi setup, these optimizations are crucial. K3s gives us a fully compliant Kubernetes experience while respecting the hardware limitations of our Pi.\nKubernetes Core Objects and Concepts Now that we understand the architecture, let’s explore some key Kubernetes objects that we’ll be working with:\nPods A Pod is the smallest deployable unit in Kubernetes. It represents a single instance of a running process in your cluster and can contain one or more containers that are tightly coupled.\nKey characteristics:\nPods are ephemeral (they can be deleted and replaced at any time) All containers in a Pod share the same network namespace (IP and port space) Containers within a Pod can communicate via localhost Pods are scheduled onto nodes as complete units Deployments A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate.\nKey benefits:\nDescribe your desired application state Deployments can scale up or down the number of replicas Perform rolling updates without downtime Roll back to earlier Deployment versions if necessary Services A Service is an abstraction that defines a logical set of Pods and a policy to access them. Since Pods are ephemeral, Services provide a stable endpoint to connect to the application.\nTypes of Services:\nClusterIP: Exposes the Service on an internal IP (default) NodePort: Exposes the Service on each Node’s IP at a static port LoadBalancer: Exposes the Service externally using a cloud provider’s load balancer ExternalName: Maps the Service to a DNS name Volumes Volumes enable data persistence beyond the lifecycle of a Pod. Kubernetes supports many types of volumes, from local storage to cloud provider offerings.\nFor our P4ndaLab, we’ll primarily use local persistent volumes backed by our USB SSD.\nConfigMaps and Secrets These objects help separate configuration from application code:\nConfigMaps: Store non-confidential configuration data Secrets: Store sensitive information like passwords and tokens Working with Kubernetes: The Workflow Understanding how to interact with Kubernetes is as important as knowing its components. Here’s a typical workflow:\nDefine your application: Create YAML manifests describing your desired state Apply manifests: Submit these definitions to the API server Kubernetes processes the request: The control plane schedules your workloads Monitor and manage: Use kubectl to interact with your application All of this is based on a declarative approach: you tell Kubernetes what you want, not how to do it.\nKubernetes Networking Networking is a crucial aspect of Kubernetes. Here’s what you need to know:\nBasic Principles Every Pod gets its own IP address Pods on a node can communicate with all Pods on all nodes without NAT Agents on a node can communicate with all Pods on that node Cluster Networking Components Pod Network: Enabled by CNI plugins (like Flannel in K3s) Services: Provide stable endpoints for pod access Ingress Controllers: Manage external access to services (HTTP/HTTPS) CoreDNS: Provides DNS-based service discovery For our P4ndaLab, K3s comes with Flannel for Pod networking and Traefik as the Ingress controller, making our setup much simpler.\nKubernetes on Raspberry Pi: Considerations Running Kubernetes on a Raspberry Pi comes with some special considerations:\nHardware Limitations ARM Architecture: Requires ARM-compatible container images Memory Constraints: 8GB is sufficient but requires careful resource management Storage Performance: USB SSD significantly outperforms SD cards Network Performance: Gigabit Ethernet is preferred over Wi-Fi Software Adaptations Lightweight Distribution: K3s instead of full Kubernetes Resource Limits: Set appropriate CPU/memory limits for workloads Node Features: Some advanced features may be limited or unavailable Image Selection: Choose lightweight, ARM-compatible images Despite these limitations, a Raspberry Pi is perfectly capable of running a functional Kubernetes environment for learning and small projects.\nWhat’s Coming Next Now that we’ve covered the theory, in the next post we’ll dive into the hands-on implementation of our Kubernetes cluster on the Raspberry Pi. We’ll walk through:\nSetting up persistent storage with our USB SSD Configuring networking for our cluster Creating our first deployments Exposing services to our network I’m excited to move from concepts to concrete implementation, and I hope you’ll join me as we continue building our P4ndaLab!\nConclusion Kubernetes may seem complex at first glance, and truthfully, it is. But by breaking it down into its component parts and understanding how they work together, we can begin to appreciate its elegant design and powerful capabilities.\nFor our P4ndaLab project, Kubernetes provides a platform that mirrors what’s used in production environments worldwide, giving us valuable hands-on experience that translates directly to real-world skills.\nWhether you’re following along to build your own homelab or just curious about Kubernetes, I hope this post has demystified some of the core concepts and architecture. Remember, the best way to learn is by doing - so in the next post, we’ll roll up our sleeves and start building!\nUntil then, happy hacking!\nHave questions or suggestions for the P4ndaLab project? Suggest your changes using the link at the top of the post under the title\n","wordCount":"2405","inLanguage":"en","image":"https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core.png","datePublished":"2025-05-11T00:00:00Z","dateModified":"2025-05-11T00:00:00Z","author":{"@type":"Person","name":"Salim"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/"},"publisher":{"@type":"Person","name":"54L1M","logo":{"@type":"ImageObject","url":"https://54L1M.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://54L1M.io/ accesskey=h title="54L1M (Alt + H)">54L1M</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://54L1M.io/about/ title=About><span>About</span></a></li><li><a href=https://54L1M.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://54L1M.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://54L1M.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://54L1M.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://54L1M.io/>Home</a>&nbsp;»&nbsp;<a href=https://54L1M.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture</h1><div class=post-meta><span title='2025-05-11 00:00:00 +0000 UTC'>May 11, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2405 words&nbsp;·&nbsp;Salim&nbsp;|&nbsp;<a href=https://github.com/54L1M/54L1M.io/tree/master/content/posts/P4ndaLab/part-2-core-concepts/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager srcset='https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core_hu_ce529093d3fc3751.png 360w,https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core_hu_e6c52ccf4be2978a.png 480w,https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core_hu_4a2d740527451394.png 720w,https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core.png 1024w' src=https://54L1M.io/2025/05/p4ndalab-understanding-kubernetes-core-concepts-and-architecture/k8s-core.png sizes="(min-width: 768px) 720px, 100vw" width=1024 height=1024 alt="Kubernetes Architecture"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#what-is-kubernetes>What is Kubernetes?</a></li><li><a href=#why-kubernetes-matters>Why Kubernetes Matters</a></li><li><a href=#kubernetes-vs-traditional-deployment>Kubernetes vs. Traditional Deployment</a><ul><li><a href=#traditional-deployment>Traditional Deployment</a></li><li><a href=#virtualized-deployment>Virtualized Deployment</a></li><li><a href=#container-deployment>Container Deployment</a></li><li><a href=#kubernetes-deployment>Kubernetes Deployment</a></li></ul></li><li><a href=#the-kubernetes-architecture>The Kubernetes Architecture</a><ul><li><a href=#high-level-view>High-Level View</a></li><li><a href=#control-plane-components>Control Plane Components</a></li><li><a href=#worker-node-components>Worker Node Components</a></li></ul></li><li><a href=#k3s-kubernetes-for-resource-constrained-environments>K3s: Kubernetes for Resource-Constrained Environments</a><ul><li><a href=#what-is-k3s>What is K3s?</a></li><li><a href=#k3s-vs-standard-kubernetes-k8s>K3s vs Standard Kubernetes (K8s)</a></li><li><a href=#k3s-architecture-specifics>K3s Architecture Specifics</a></li></ul></li><li><a href=#kubernetes-core-objects-and-concepts>Kubernetes Core Objects and Concepts</a><ul><li><a href=#pods>Pods</a></li><li><a href=#deployments>Deployments</a></li><li><a href=#services>Services</a></li><li><a href=#volumes>Volumes</a></li><li><a href=#configmaps-and-secrets>ConfigMaps and Secrets</a></li></ul></li><li><a href=#working-with-kubernetes-the-workflow>Working with Kubernetes: The Workflow</a></li><li><a href=#kubernetes-networking>Kubernetes Networking</a><ul><li><a href=#basic-principles>Basic Principles</a></li><li><a href=#cluster-networking-components>Cluster Networking Components</a></li></ul></li><li><a href=#kubernetes-on-raspberry-pi-considerations>Kubernetes on Raspberry Pi: Considerations</a><ul><li><a href=#hardware-limitations>Hardware Limitations</a></li><li><a href=#software-adaptations>Software Adaptations</a></li></ul></li><li><a href=#whats-coming-next>What&rsquo;s Coming Next</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-series><h4>P4ndaLab Series</h4><ul><li><a href=https://54L1M.io/2025/05/introducing-p4ndalab-my-kubernetes-homelab-journey-on-raspberry-pi/>Introducing P4ndaLab: My Kubernetes Homelab Journey on Raspberry Pi</a></li><li><strong>P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture</strong> (current)</li></ul></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Welcome to the second post in my P4ndaLab series! Last time, I introduced you to my Raspberry Pi Kubernetes homelab project and outlined my learning journey. Today, we&rsquo;re diving into Kubernetes itself - what it is, why it matters, and how it&rsquo;s structured. This post combines both theoretical concepts and architectural details to give you a solid foundation before we get our hands dirty with the implementation.</p><p>As I mentioned in my first post, I believe in learning by doing. But to do effectively, we first need to understand what we&rsquo;re working with. So let&rsquo;s unpack this powerful technology that&rsquo;s reshaping how we deploy and manage applications.</p><h2 id=what-is-kubernetes>What is Kubernetes?<a hidden class=anchor aria-hidden=true href=#what-is-kubernetes>#</a></h2><p>At its core, Kubernetes (often abbreviated as K8s - 8 letters between &lsquo;K&rsquo; and &rsquo;s&rsquo;) is an open-source container orchestration platform. But what does that actually mean?</p><p>Think of it this way: if containers (like Docker) are a better way to package and run individual applications, Kubernetes is a better way to manage many containers across multiple machines. It automates the deployment, scaling, and management of containerized applications, handling all the complex logistics so you don&rsquo;t have to.</p><p>Originally developed by Google based on their internal system called Borg, Kubernetes was released as an open-source project in 2014 and is now maintained by the Cloud Native Computing Foundation (CNCF). It has since become the industry standard for container orchestration.</p><h2 id=why-kubernetes-matters>Why Kubernetes Matters<a hidden class=anchor aria-hidden=true href=#why-kubernetes-matters>#</a></h2><p>You might wonder why we need something as complex as Kubernetes, especially for a homelab. Here&rsquo;s why it&rsquo;s worth learning:</p><ol><li><strong>Automation at scale</strong>: Kubernetes automates many manual processes involved in deploying and scaling applications.</li><li><strong>Self-healing capabilities</strong>: If a container fails, Kubernetes can automatically restart it or replace it.</li><li><strong>Service discovery and load balancing</strong>: Kubernetes can expose containers using DNS names or IP addresses and distribute network traffic.</li><li><strong>Storage orchestration</strong>: You can mount storage systems of your choice, whether local or cloud-based.</li><li><strong>Declarative configuration</strong>: You tell Kubernetes what you want your deployed application to look like, and it figures out how to make it happen.</li><li><strong>Portable across environments</strong>: Whether running on-premises, in a public cloud, or a hybrid setup, Kubernetes works the same way.</li></ol><p>For my P4ndaLab, Kubernetes provides a consistent platform to experiment with modern application deployment patterns and technologies that are widely used in the industry.</p><h2 id=kubernetes-vs-traditional-deployment>Kubernetes vs. Traditional Deployment<a hidden class=anchor aria-hidden=true href=#kubernetes-vs-traditional-deployment>#</a></h2><p>To better understand Kubernetes, let&rsquo;s compare it with traditional deployment methods:</p><h3 id=traditional-deployment>Traditional Deployment<a hidden class=anchor aria-hidden=true href=#traditional-deployment>#</a></h3><ul><li>Applications run directly on physical servers</li><li>One application per server to avoid resource conflicts</li><li>Results in underutilized hardware and high maintenance costs</li><li>Scaling requires provisioning new servers</li><li>Disaster recovery is manual and time-consuming</li></ul><h3 id=virtualized-deployment>Virtualized Deployment<a hidden class=anchor aria-hidden=true href=#virtualized-deployment>#</a></h3><ul><li>Multiple VMs run on a single physical server</li><li>Applications isolated within VMs</li><li>Better resource utilization than traditional deployment</li><li>Scaling still relatively complex</li><li>VM provisioning and maintenance overhead</li></ul><h3 id=container-deployment>Container Deployment<a hidden class=anchor aria-hidden=true href=#container-deployment>#</a></h3><ul><li>Lightweight and portable</li><li>Share OS kernel but isolated at process level</li><li>Fast startup and lower overhead than VMs</li><li>Easy to build and deploy</li><li>Still need container orchestration for production use</li></ul><h3 id=kubernetes-deployment>Kubernetes Deployment<a hidden class=anchor aria-hidden=true href=#kubernetes-deployment>#</a></h3><ul><li>Automates container management across multiple nodes</li><li>Declarative approach to application deployment</li><li>Built-in scaling, load balancing, and self-healing</li><li>Infrastructure abstraction - you work with logical resources</li><li>Consistent environment from development to production</li></ul><h2 id=the-kubernetes-architecture>The Kubernetes Architecture<a hidden class=anchor aria-hidden=true href=#the-kubernetes-architecture>#</a></h2><p>Now that we understand what Kubernetes is and why it matters, let&rsquo;s look at how it&rsquo;s built. Kubernetes follows a master-worker architecture that&rsquo;s both elegant and robust.</p><h3 id=high-level-view>High-Level View<a hidden class=anchor aria-hidden=true href=#high-level-view>#</a></h3><p>At a high level, a Kubernetes cluster consists of two types of nodes:</p><ol><li><strong>Control Plane (Master) Nodes</strong>: Manage the cluster</li><li><strong>Worker Nodes</strong>: Run the actual workloads (your applications)</li></ol><p>Here&rsquo;s a simplified view of what this looks like:</p><pre tabindex=0><code>┌─────────────────────────────────────────────────────────────┐
│                     Kubernetes Cluster                      │
│                                                             │
│  ┌───────────────────────┐      ┌──────────────────────┐    │
│  │    Control Plane      │      │     Worker Node 1    │    │
│  │                       │      │                      │    │
│  │  ┌─────────────────┐  │      │  ┌───────────────┐   │    │
│  │  │   API Server    │  │      │  │    Kubelet    │   │    │
│  │  └─────────────────┘  │      │  └───────────────┘   │    │
│  │                       │      │                      │    │
│  │  ┌─────────────────┐  │      │  ┌───────────────┐   │    │
│  │  │  Scheduler      │  │      │  │   Kube-proxy  │   │    │
│  │  └─────────────────┘  │      │  └───────────────┘   │    │
│  │                       │      │                      │    │
│  │  ┌─────────────────┐  │      │  ┌───────────────┐   │    │
│  │  │ Controller Mgr  │  │      │  │ Container RT  │   │    │
│  │  └─────────────────┘  │      │  └───────────────┘   │    │
│  │                       │      │                      │    │
│  │  ┌─────────────────┐  │      │  ┌───────────────┐   │    │
│  │  │      etcd       │  │      │  │     Pods      │   │    │
│  │  └─────────────────┘  │      │  └───────────────┘   │    │
│  └───────────────────────┘      └──────────────────────┘    │
│                                                             │
│                                  ┌──────────────────────┐   │
│                                  │     Worker Node 2    │   │
│                                  │         ...          │   │
│                                  └──────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
</code></pre><p>Let&rsquo;s break down each component in detail.</p><h3 id=control-plane-components>Control Plane Components<a hidden class=anchor aria-hidden=true href=#control-plane-components>#</a></h3><p>The control plane is the brain of Kubernetes. Its components make global decisions about the cluster and detect and respond to events. In a production environment, control plane components are typically run across multiple computers for high availability, but for our P4ndaLab, they&rsquo;ll run on a single node.</p><h4 id=api-server-kube-apiserver>API Server (kube-apiserver)<a hidden class=anchor aria-hidden=true href=#api-server-kube-apiserver>#</a></h4><p>The API server is the front door to the Kubernetes control plane. All external communication with the cluster goes through the API server - whether it&rsquo;s from users running <code>kubectl</code> commands, other parts of the control plane, or external systems.</p><p><strong>Key responsibilities:</strong></p><ul><li>Validates and processes API requests</li><li>Acts as a gateway for the control plane</li><li>Serves as the connection point for all components</li><li>Performs authentication and authorization</li><li>Provides RESTful API operations</li></ul><p>The API server is designed to scale horizontally, meaning you can run multiple instances to distribute load.</p><h4 id=etcd>etcd<a hidden class=anchor aria-hidden=true href=#etcd>#</a></h4><p>Think of etcd as the cluster&rsquo;s database. It&rsquo;s a consistent, distributed key-value store that reliably stores all of Kubernetes&rsquo; configuration data and cluster state.</p><p><strong>Key responsibilities:</strong></p><ul><li>Stores all cluster data</li><li>Provides watch-based notification of changes</li><li>Offers strong consistency guarantees</li><li>Provides the single source of truth for the cluster</li></ul><p>When you execute a command like <code>kubectl get pods</code>, the API server reads data from etcd. When you create a new deployment, that configuration is stored in etcd.</p><h4 id=scheduler-kube-scheduler>Scheduler (kube-scheduler)<a hidden class=anchor aria-hidden=true href=#scheduler-kube-scheduler>#</a></h4><p>The scheduler&rsquo;s job is to assign newly created pods to nodes. It&rsquo;s like an intelligent dispatcher that decides where each workload should run.</p><p><strong>Key responsibilities:</strong></p><ul><li>Watches for newly created pods with no assigned node</li><li>Selects the best node for each pod based on various factors</li><li>Considers resource requirements, hardware/software constraints, and affinity/anti-affinity specifications</li><li>Makes binding decisions (assigns pods to nodes)</li></ul><p>The scheduler doesn&rsquo;t actually place the pod on the node; it simply updates the pod definition with the node assignment, and the kubelet on that node does the rest.</p><h4 id=controller-manager-kube-controller-manager>Controller Manager (kube-controller-manager)<a hidden class=anchor aria-hidden=true href=#controller-manager-kube-controller-manager>#</a></h4><p>The controller manager runs controller processes that regulate the state of the cluster. A controller is a control loop that watches the shared state of the cluster and makes changes to move the current state towards the desired state.</p><p><strong>Key controllers:</strong></p><ul><li><strong>Node Controller</strong>: Notices and responds when nodes go down</li><li><strong>Replication Controller</strong>: Maintains the correct number of pods for each ReplicaSet</li><li><strong>Endpoints Controller</strong>: Populates Endpoint objects (joins Services & Pods)</li><li><strong>Service Account & Token Controllers</strong>: Create default accounts and API access tokens</li></ul><h4 id=cloud-controller-manager>Cloud Controller Manager<a hidden class=anchor aria-hidden=true href=#cloud-controller-manager>#</a></h4><p>This component links your cluster with your cloud provider&rsquo;s API. For a homelab setup like ours, this component isn&rsquo;t particularly relevant since we&rsquo;re not running in a cloud environment. But it&rsquo;s worth knowing about for completeness.</p><h3 id=worker-node-components>Worker Node Components<a hidden class=anchor aria-hidden=true href=#worker-node-components>#</a></h3><p>Worker nodes are the machines where your applications actually run. Each node includes the services necessary to run pods and is managed by the control plane.</p><h4 id=kubelet>Kubelet<a hidden class=anchor aria-hidden=true href=#kubelet>#</a></h4><p>The kubelet is an agent that runs on each node in the cluster. It&rsquo;s responsible for making sure that containers are running in a pod.</p><p><strong>Key responsibilities:</strong></p><ul><li>Communicates with the API server</li><li>Takes a set of PodSpecs and ensures the containers described are running and healthy</li><li>Reports node and pod status to the master</li><li>Runs container health checks</li><li>Manages container lifecycle based on PodSpecs</li></ul><h4 id=kube-proxy>Kube-proxy<a hidden class=anchor aria-hidden=true href=#kube-proxy>#</a></h4><p>Kube-proxy is a network proxy that runs on each node, implementing part of the Kubernetes Service concept.</p><p><strong>Key responsibilities:</strong></p><ul><li>Maintains network rules on nodes</li><li>Handles network communications inside or outside of your cluster</li><li>Performs connection forwarding</li><li>Implements services abstraction</li></ul><p>Kube-proxy uses the operating system packet filtering layer if available, otherwise, it forwards the traffic itself.</p><h4 id=container-runtime>Container Runtime<a hidden class=anchor aria-hidden=true href=#container-runtime>#</a></h4><p>The container runtime is the software responsible for running containers. Kubernetes supports several container runtimes including Docker, containerd, and CRI-O.</p><p>For our P4ndaLab, we&rsquo;ll be using K3s, which includes containerd as its container runtime by default.</p><h2 id=k3s-kubernetes-for-resource-constrained-environments>K3s: Kubernetes for Resource-Constrained Environments<a hidden class=anchor aria-hidden=true href=#k3s-kubernetes-for-resource-constrained-environments>#</a></h2><p>Speaking of K3s, let&rsquo;s talk about what makes it special and why I&rsquo;ve chosen it for P4ndaLab.</p><h3 id=what-is-k3s>What is K3s?<a hidden class=anchor aria-hidden=true href=#what-is-k3s>#</a></h3><p>K3s is a certified Kubernetes distribution designed for resource-constrained environments like IoT devices, edge computing, and in our case, a Raspberry Pi. Created by Rancher Labs (now part of SUSE), K3s packages Kubernetes as a single binary less than 100MB in size.</p><h3 id=k3s-vs-standard-kubernetes-k8s>K3s vs Standard Kubernetes (K8s)<a hidden class=anchor aria-hidden=true href=#k3s-vs-standard-kubernetes-k8s>#</a></h3><table><thead><tr><th>Feature</th><th>Standard K8s</th><th>K3s</th></tr></thead><tbody><tr><td>Binary size</td><td>~200MB+</td><td>&lt;100MB</td></tr><tr><td>Memory footprint</td><td>2GB+ recommended</td><td>512MB minimum</td></tr><tr><td>Setup complexity</td><td>High</td><td>Low (single command)</td></tr><tr><td>External dependencies</td><td>Multiple</td><td>Minimal</td></tr><tr><td>Default components</td><td>Minimal</td><td>Includes storage, load balancer, etc.</td></tr><tr><td>Storage backend</td><td>etcd</td><td>SQLite (default) or etcd</td></tr></tbody></table><h3 id=k3s-architecture-specifics>K3s Architecture Specifics<a hidden class=anchor aria-hidden=true href=#k3s-architecture-specifics>#</a></h3><p>K3s modifies the standard Kubernetes architecture to be more lightweight:</p><ol><li><strong>Single Binary</strong>: Combines control plane components for efficiency</li><li><strong>Embedded Components</strong>: Includes containerd, Flannel, CoreDNS, local storage provider, Traefik ingress, and more</li><li><strong>Simplified Management</strong>: Automatic TLS certificate generation and rotation</li><li><strong>Storage Options</strong>: Uses SQLite by default for single-node deployments, with etcd available for HA clusters</li></ol><p>For our Raspberry Pi setup, these optimizations are crucial. K3s gives us a fully compliant Kubernetes experience while respecting the hardware limitations of our Pi.</p><h2 id=kubernetes-core-objects-and-concepts>Kubernetes Core Objects and Concepts<a hidden class=anchor aria-hidden=true href=#kubernetes-core-objects-and-concepts>#</a></h2><p>Now that we understand the architecture, let&rsquo;s explore some key Kubernetes objects that we&rsquo;ll be working with:</p><h3 id=pods>Pods<a hidden class=anchor aria-hidden=true href=#pods>#</a></h3><p>A Pod is the smallest deployable unit in Kubernetes. It represents a single instance of a running process in your cluster and can contain one or more containers that are tightly coupled.</p><p><strong>Key characteristics:</strong></p><ul><li>Pods are ephemeral (they can be deleted and replaced at any time)</li><li>All containers in a Pod share the same network namespace (IP and port space)</li><li>Containers within a Pod can communicate via localhost</li><li>Pods are scheduled onto nodes as complete units</li></ul><h3 id=deployments>Deployments<a hidden class=anchor aria-hidden=true href=#deployments>#</a></h3><p>A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate.</p><p><strong>Key benefits:</strong></p><ul><li>Describe your desired application state</li><li>Deployments can scale up or down the number of replicas</li><li>Perform rolling updates without downtime</li><li>Roll back to earlier Deployment versions if necessary</li></ul><h3 id=services>Services<a hidden class=anchor aria-hidden=true href=#services>#</a></h3><p>A Service is an abstraction that defines a logical set of Pods and a policy to access them. Since Pods are ephemeral, Services provide a stable endpoint to connect to the application.</p><p><strong>Types of Services:</strong></p><ul><li><strong>ClusterIP</strong>: Exposes the Service on an internal IP (default)</li><li><strong>NodePort</strong>: Exposes the Service on each Node&rsquo;s IP at a static port</li><li><strong>LoadBalancer</strong>: Exposes the Service externally using a cloud provider&rsquo;s load balancer</li><li><strong>ExternalName</strong>: Maps the Service to a DNS name</li></ul><h3 id=volumes>Volumes<a hidden class=anchor aria-hidden=true href=#volumes>#</a></h3><p>Volumes enable data persistence beyond the lifecycle of a Pod. Kubernetes supports many types of volumes, from local storage to cloud provider offerings.</p><p>For our P4ndaLab, we&rsquo;ll primarily use local persistent volumes backed by our USB SSD.</p><h3 id=configmaps-and-secrets>ConfigMaps and Secrets<a hidden class=anchor aria-hidden=true href=#configmaps-and-secrets>#</a></h3><p>These objects help separate configuration from application code:</p><ul><li><strong>ConfigMaps</strong>: Store non-confidential configuration data</li><li><strong>Secrets</strong>: Store sensitive information like passwords and tokens</li></ul><h2 id=working-with-kubernetes-the-workflow>Working with Kubernetes: The Workflow<a hidden class=anchor aria-hidden=true href=#working-with-kubernetes-the-workflow>#</a></h2><p>Understanding how to interact with Kubernetes is as important as knowing its components. Here&rsquo;s a typical workflow:</p><ol><li><strong>Define your application</strong>: Create YAML manifests describing your desired state</li><li><strong>Apply manifests</strong>: Submit these definitions to the API server</li><li><strong>Kubernetes processes the request</strong>: The control plane schedules your workloads</li><li><strong>Monitor and manage</strong>: Use kubectl to interact with your application</li></ol><p>All of this is based on a declarative approach: you tell Kubernetes what you want, not how to do it.</p><h2 id=kubernetes-networking>Kubernetes Networking<a hidden class=anchor aria-hidden=true href=#kubernetes-networking>#</a></h2><p>Networking is a crucial aspect of Kubernetes. Here&rsquo;s what you need to know:</p><h3 id=basic-principles>Basic Principles<a hidden class=anchor aria-hidden=true href=#basic-principles>#</a></h3><ul><li>Every Pod gets its own IP address</li><li>Pods on a node can communicate with all Pods on all nodes without NAT</li><li>Agents on a node can communicate with all Pods on that node</li></ul><h3 id=cluster-networking-components>Cluster Networking Components<a hidden class=anchor aria-hidden=true href=#cluster-networking-components>#</a></h3><ol><li><strong>Pod Network</strong>: Enabled by CNI plugins (like Flannel in K3s)</li><li><strong>Services</strong>: Provide stable endpoints for pod access</li><li><strong>Ingress Controllers</strong>: Manage external access to services (HTTP/HTTPS)</li><li><strong>CoreDNS</strong>: Provides DNS-based service discovery</li></ol><p>For our P4ndaLab, K3s comes with Flannel for Pod networking and Traefik as the Ingress controller, making our setup much simpler.</p><h2 id=kubernetes-on-raspberry-pi-considerations>Kubernetes on Raspberry Pi: Considerations<a hidden class=anchor aria-hidden=true href=#kubernetes-on-raspberry-pi-considerations>#</a></h2><p>Running Kubernetes on a Raspberry Pi comes with some special considerations:</p><h3 id=hardware-limitations>Hardware Limitations<a hidden class=anchor aria-hidden=true href=#hardware-limitations>#</a></h3><ul><li><strong>ARM Architecture</strong>: Requires ARM-compatible container images</li><li><strong>Memory Constraints</strong>: 8GB is sufficient but requires careful resource management</li><li><strong>Storage Performance</strong>: USB SSD significantly outperforms SD cards</li><li><strong>Network Performance</strong>: Gigabit Ethernet is preferred over Wi-Fi</li></ul><h3 id=software-adaptations>Software Adaptations<a hidden class=anchor aria-hidden=true href=#software-adaptations>#</a></h3><ul><li><strong>Lightweight Distribution</strong>: K3s instead of full Kubernetes</li><li><strong>Resource Limits</strong>: Set appropriate CPU/memory limits for workloads</li><li><strong>Node Features</strong>: Some advanced features may be limited or unavailable</li><li><strong>Image Selection</strong>: Choose lightweight, ARM-compatible images</li></ul><p>Despite these limitations, a Raspberry Pi is perfectly capable of running a functional Kubernetes environment for learning and small projects.</p><h2 id=whats-coming-next>What&rsquo;s Coming Next<a hidden class=anchor aria-hidden=true href=#whats-coming-next>#</a></h2><p>Now that we&rsquo;ve covered the theory, in the next post we&rsquo;ll dive into the hands-on implementation of our Kubernetes cluster on the Raspberry Pi. We&rsquo;ll walk through:</p><ol><li>Setting up persistent storage with our USB SSD</li><li>Configuring networking for our cluster</li><li>Creating our first deployments</li><li>Exposing services to our network</li></ol><p>I&rsquo;m excited to move from concepts to concrete implementation, and I hope you&rsquo;ll join me as we continue building our P4ndaLab!</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Kubernetes may seem complex at first glance, and truthfully, it is. But by breaking it down into its component parts and understanding how they work together, we can begin to appreciate its elegant design and powerful capabilities.</p><p>For our P4ndaLab project, Kubernetes provides a platform that mirrors what&rsquo;s used in production environments worldwide, giving us valuable hands-on experience that translates directly to real-world skills.</p><p>Whether you&rsquo;re following along to build your own homelab or just curious about Kubernetes, I hope this post has demystified some of the core concepts and architecture. Remember, the best way to learn is by doing - so in the next post, we&rsquo;ll roll up our sleeves and start building!</p><p>Until then, happy hacking!</p><hr><p><em>Have questions or suggestions for the P4ndaLab project? Suggest your changes using the link at the top of the post under the title</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://54L1M.io/tags/kubernetes/>Kubernetes</a></li><li><a href=https://54L1M.io/tags/raspberry-pi/>Raspberry-Pi</a></li><li><a href=https://54L1M.io/tags/homelab/>Homelab</a></li><li><a href=https://54L1M.io/tags/k3s/>K3s</a></li><li><a href=https://54L1M.io/tags/p4ndalab/>P4ndalab</a></li><li><a href=https://54L1M.io/tags/k8s/>K8s</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture on x" href="https://x.com/intent/tweet/?text=P4ndaLab%3a%20Understanding%20Kubernetes%20-%20Core%20Concepts%20and%20Architecture&amp;url=https%3a%2f%2f54L1M.io%2f2025%2f05%2fp4ndalab-understanding-kubernetes-core-concepts-and-architecture%2f&amp;hashtags=kubernetes%2craspberry-pi%2chomelab%2ck3s%2cp4ndalab%2ck8s"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f54L1M.io%2f2025%2f05%2fp4ndalab-understanding-kubernetes-core-concepts-and-architecture%2f&amp;title=P4ndaLab%3a%20Understanding%20Kubernetes%20-%20Core%20Concepts%20and%20Architecture&amp;summary=P4ndaLab%3a%20Understanding%20Kubernetes%20-%20Core%20Concepts%20and%20Architecture&amp;source=https%3a%2f%2f54L1M.io%2f2025%2f05%2fp4ndalab-understanding-kubernetes-core-concepts-and-architecture%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture on whatsapp" href="https://api.whatsapp.com/send?text=P4ndaLab%3a%20Understanding%20Kubernetes%20-%20Core%20Concepts%20and%20Architecture%20-%20https%3a%2f%2f54L1M.io%2f2025%2f05%2fp4ndalab-understanding-kubernetes-core-concepts-and-architecture%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share P4ndaLab: Understanding Kubernetes - Core Concepts and Architecture on telegram" href="https://telegram.me/share/url?text=P4ndaLab%3a%20Understanding%20Kubernetes%20-%20Core%20Concepts%20and%20Architecture&amp;url=https%3a%2f%2f54L1M.io%2f2025%2f05%2fp4ndalab-understanding-kubernetes-core-concepts-and-architecture%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>